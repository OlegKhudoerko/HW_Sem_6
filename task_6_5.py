# 5. ** Реализовать функцию, возвращающую n шуток,
# сформированных из трех случайных слов, взятых из трёх списков (по одному из каждого)
# nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
# adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью", "когда-то", "где-то"]
# adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]

# in
# 10 True

# out

# ['дом ночью мягкий', 'огонь завтра зеленый', 'лес вчера яркий', 'автомобиль сегодня веселый',
# 'город позавчера утопичный']

# in
# 10 False

# out

# ['автомобиль ночью мягкий', 'огонь вчера веселый', 'автомобиль позавчера веселый',
# 'город вчера утопичный', 'лес сегодня зеленый', 'дом вчера яркий', 'автомобиль вчера зеленый',
# 'огонь позавчера яркий', 'огонь где-то утопичный', 'автомобиль где-то мягкий']

from random import choice, randrange


def joces(count, bool_in):
    a, b, d = nouns.copy(), adverbs.copy(), adjectives.copy()
    ls_joces = []
    ls = min(a, b, d)
    print(*ls)
    print()
    for i in range(len(ls) % count if bool_in else count):
        j = randrange(len(ls))
        try:
            ls_joces.append(
                f"{a.pop(j)} {b.pop(j)} {d.pop(j)}" if bool_in else f"{choice(a)} {choice(b)} {choice(d)}")
        except IndexError:
            return ls_joces
    return ls_joces


nouns = ["автомобиль", "лес", "огонь", "город",
         "человек", "поезд", "самолет", "пароход"]
adverbs = ["сегодня", "вчера", "завтра",
           "позавчера", "ночью", "когда-то", "где-то"]
adjectives = ["веселый", "яркий", "зеленый",
              "утопичный", "мягкий", "смешной", "никакой"]

print(joces(10, True))
# print(joces(10,False))
